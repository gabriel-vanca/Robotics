Our solution to the midterm task is based on a simple idea of storing the speeds of the robot's wheels in a dynamic structure for when the robot is going forwards and then reusing those speeds to make the robot go backwards to the same position where it started.
For going forwards, I have implemented a PID controller (present in movement.h)  that my team-mate (Eduard Ursinschi) calibrated.  The PID is returning a value which we add to a standard speed for the left wheel and subtract from the same standard speed for the right wheel. During the way forwards, we store this value which practically facilitates storing the speeds for both wheels but using just one variable.
Though we have initially started with an array, we decided that the best option, due to limited memory, is to use a linked list. I have implemented the linked list, but, then, after consultations with Eduard, I have converted the linked list into a stack as we actually need to parse the values from end to the beginning at return. When we parse the values, we change the speeds of the wheels accordingly, in reverse order (left speeds used for right wheel and vice-versa).
Though this idea seems good on paper, we had two main issues: first - we were running out of memory; second - our robot was not applying the return speeds appropriately.
The first problem was due to the fact that we were putting too many values in the stack and the second issue was due to the fact that we were not taking into account the time it took different functions to compute (for example the PID function - this has been observed by Eduard after endless testing and code adjustments).
The way we solved the first issue was by using the Dead Reckoning technique (the calculations were done by Eduard and the code was implemented by me). Practically, we are tracking the angle change and if the angle has changed very slowly, we don't add a new value, we just adjust the existing speed using a ponderate average based on the number of times that the speed remained constant. We only add values in the stack when there is a sharp angle change.
After implementing this solution, we were no longer running out of memory, but our robot was even more out of sync at return. This was because the Dead Reckoning technique (as well as the ponderate average in a smaller scale) were taking a lot of time to compute (PID + Dead Recocking are taking between 45 and 80 milliseconds, depending on the input values). The way we managed to solve this issue is by actually looking at the ticks of the ActivityBot's CPU. I have managed to convert the CPU ticks into millisecond and measure this way the time it took for different functions to compute. Then we have stored that time into our structure and we taking it into account when the robot is going backwards.
